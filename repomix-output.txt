This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-11T10:31:38.188Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.gitattributes
.github/workflows/release.yml
background/background.js
content-scripts/chatgpt.js
content-scripts/gemini.js
content-scripts/mheducation.js
LICENSE
manifest.json
popup/settings.css
popup/settings.html
popup/settings.js
README.md

================================================================
Repository Files
================================================================

================
File: .gitattributes
================
# Auto detect text files and perform LF normalization
* text=auto

================
File: .github/workflows/release.yml
================
name: Create Release

on:
  push:
    branches:
      - main
    paths:
      - 'manifest.json'

jobs:
  check-version:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.get-version.outputs.version }}
      has_changed: ${{ steps.version-check.outputs.has_changed }}
      last_tag: ${{ steps.get-latest-tag.outputs.tag }}
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0
      
      - name: Get version from manifest
        id: get-version
        run: |
          VERSION=$(jq -r .version manifest.json)
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Get latest tag
        id: get-latest-tag
        run: |
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "none")
          echo "tag=$LATEST_TAG" >> $GITHUB_OUTPUT

      - name: Check if version changed
        id: version-check
        run: |
          MANIFEST_VERSION=$(jq -r .version manifest.json)
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "none")
          if [ "$LATEST_TAG" = "none" ] || [ "v$MANIFEST_VERSION" != "$LATEST_TAG" ]; then
            echo "has_changed=true" >> $GITHUB_OUTPUT
          else
            echo "has_changed=false" >> $GITHUB_OUTPUT
          fi

  create-release:
    needs: check-version
    if: needs.check-version.outputs.has_changed == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Generate changelog
        id: changelog
        run: |
          LATEST_TAG="${{ needs.check-version.outputs.last_tag }}"
          if [ "$LATEST_TAG" = "none" ]; then
            CHANGELOG=$(git log --pretty=format:"* %s (%h)" --no-merges)
          else
            CHANGELOG=$(git log --pretty=format:"* %s (%h)" --no-merges $LATEST_TAG..HEAD)
          fi
          echo "CHANGELOG<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGELOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create zip file
        run: |
          zip -r auto-mcgraw.zip . -x "*.git*" -x "*.github*" -x "*.zip"

      - name: Create Release
        id: create_release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ needs.check-version.outputs.version }}
          name: Release v${{ needs.check-version.outputs.version }}
          body: |
            Changes in this release:
            
            ${{ steps.changelog.outputs.CHANGELOG }}
          files: auto-mcgraw.zip
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

================
File: background/background.js
================
function sendMessageWithRetry(tabId, message, maxAttempts = 3, delay = 1000) {
  let attempts = 0;

  function attemptSend() {
    attempts++;
    chrome.tabs.sendMessage(tabId, message, (response) => {
      if (chrome.runtime.lastError) {
        if (attempts < maxAttempts) {
          setTimeout(attemptSend, delay);
        }
      }
    });
  }

  attemptSend();
}

chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  if (message.type === "sendQuestionToChatGPT") {
    chrome.storage.sync.get("aiModel", function (data) {
      const aiModel = data.aiModel || "chatgpt";

      if (aiModel === "chatgpt") {
        chrome.tabs.query({ url: "https://chatgpt.com/*" }, (chatgptTabs) => {
          if (chatgptTabs.length > 0) {
            sendMessageWithRetry(chatgptTabs[0].id, {
              type: "receiveQuestion",
              question: message.question,
            });
          }
        });
      } else {
        chrome.tabs.query(
          { url: "https://gemini.google.com/*" },
          (geminiTabs) => {
            if (geminiTabs.length > 0) {
              sendMessageWithRetry(geminiTabs[0].id, {
                type: "receiveQuestion",
                question: message.question,
              });
            }
          }
        );
      }
    });
    return true;
  }

  if (message.type === "chatGPTResponse" || message.type === "geminiResponse") {
    chrome.tabs.query(
      { url: "https://learning.mheducation.com/*" },
      (mheTabs) => {
        if (mheTabs.length === 1) {
          sendMessageWithRetry(mheTabs[0].id, {
            type: "processChatGPTResponse",
            response: message.response,
          });
        }
      }
    );
    return true;
  }

  if (message.type === "openSettings") {
    chrome.windows.create({
      url: chrome.runtime.getURL("popup/settings.html"),
      type: "popup",
      width: 400,
      height: 520,
    });
    return true;
  }
});

================
File: content-scripts/chatgpt.js
================
let hasResponded = false;
let messageCountAtQuestion = 0;

chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  if (message.type === "receiveQuestion") {
    const messages = document.querySelectorAll(
      '[data-message-author-role="assistant"]'
    );
    messageCountAtQuestion = messages.length;
    hasResponded = false;
    insertQuestion(message.question);
    sendResponse({ received: true });
    return true;
  }
});

function insertQuestion(questionData) {
  const { type, question, options } = questionData;
  let text = `Type: ${type}\nQuestion: ${question}`;

  if (type === "matching") {
    text +=
      "\nPrompts:\n" +
      options.prompts.map((prompt, i) => `${i + 1}. ${prompt}`).join("\n");
    text +=
      "\nChoices:\n" +
      options.choices.map((choice, i) => `${i + 1}. ${choice}`).join("\n");
    text +=
      "\n\nPlease match each prompt with the correct choice. Format your answer as an array where each element is 'Prompt -> Choice'.";
  } else if (type === "fill_in_the_blank") {
    text +=
      "\n\nThis is a fill in the blank question. If there are multiple blanks, provide answers as an array in order of appearance. For a single blank, you can provide a string.";
  } else if (options && options.length > 0) {
    text +=
      "\nOptions:\n" + options.map((opt, i) => `${i + 1}. ${opt}`).join("\n");
    text +=
      "\n\nIMPORTANT: Your answer must EXACTLY match one of the above options. Do not include numbers in your answer. If there are periods, include them.";
  }

  text +=
    '\n\nPlease provide your answer in JSON format with keys "answer" and "explanation".';

  const inputArea = document.getElementById("prompt-textarea");
  if (inputArea) {
    inputArea.focus();
    inputArea.innerHTML = `<p>${text}</p>`;
    inputArea.dispatchEvent(new Event("input", { bubbles: true }));

    setTimeout(() => {
      const sendButton = document.querySelector('[data-testid="send-button"]');
      if (sendButton) {
        sendButton.click();
        startObserving();
      }
    }, 500);
  }
}

function startObserving() {
  const observer = new MutationObserver((mutations) => {
    if (hasResponded) return;

    const messages = document.querySelectorAll(
      '[data-message-author-role="assistant"]'
    );
    if (!messages.length) return;

    if (messages.length <= messageCountAtQuestion) return;

    const latestMessage = messages[messages.length - 1];
    const codeBlocks = latestMessage.querySelectorAll("pre code");
    let responseText = "";

    for (const block of codeBlocks) {
      if (block.className.includes("language-json")) {
        responseText = block.textContent.trim();
        break;
      }
    }

    if (!responseText) {
      responseText = latestMessage.textContent.trim();
      const jsonMatch = responseText.match(/\{[\s\S]*\}/);
      if (jsonMatch) responseText = jsonMatch[0];
    }

    responseText = responseText
      .replace(/[\u200B-\u200D\uFEFF]/g, "")
      .replace(/\n\s*/g, " ")
      .trim();

    try {
      const parsed = JSON.parse(responseText);
      if (parsed.answer && !hasResponded) {
        hasResponded = true;
        chrome.runtime.sendMessage({
          type: "chatGPTResponse",
          response: responseText,
        });
        observer.disconnect();
      }
    } catch (e) {}
  });

  observer.observe(document.body, { childList: true, subtree: true });
}

================
File: content-scripts/gemini.js
================
let hasResponded = false;
let messageCountAtQuestion = 0;

chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  if (message.type === "receiveQuestion") {
    const messages = document.querySelectorAll("model-response");
    messageCountAtQuestion = messages.length;
    hasResponded = false;
    insertQuestion(message.question);
    sendResponse({ received: true });
    return true;
  }
});

function insertQuestion(questionData) {
  const { type, question, options } = questionData;
  let text = `Type: ${type}\nQuestion: ${question}`;

  if (type === "matching") {
    text +=
      "\nPrompts:\n" +
      options.prompts.map((prompt, i) => `${i + 1}. ${prompt}`).join("\n");
    text +=
      "\nChoices:\n" +
      options.choices.map((choice, i) => `${i + 1}. ${choice}`).join("\n");
    text +=
      "\n\nPlease match each prompt with the correct choice. Format your answer as an array where each element is 'Prompt -> Choice'.";
  } else if (type === "fill_in_the_blank") {
    text +=
      "\n\nThis is a fill in the blank question. If there are multiple blanks, provide answers as an array in order of appearance. For a single blank, you can provide a string.";
  } else if (options && options.length > 0) {
    text +=
      "\nOptions:\n" + options.map((opt, i) => `${i + 1}. ${opt}`).join("\n");
    text +=
      "\n\nIMPORTANT: Your answer must EXACTLY match one of the above options. Do not include numbers in your answer. If there are periods, include them.";
  }

  text +=
    '\n\nPlease provide your answer in JSON format with keys "answer" and "explanation".';

  const inputArea = document.querySelector(".ql-editor");
  if (inputArea) {
    inputArea.innerHTML = `<p>${text}</p>`;

    inputArea.dispatchEvent(new Event("input", { bubbles: true }));

    setTimeout(() => {
      const sendButton = document.querySelector(".send-button");
      if (sendButton) {
        sendButton.click();
        startObserving();
      }
    }, 500);
  }
}

function startObserving() {
  const observer = new MutationObserver((mutations) => {
    if (hasResponded) return;

    const messages = document.querySelectorAll("model-response");
    if (!messages.length) return;

    if (messages.length <= messageCountAtQuestion) return;

    const latestMessage = messages[messages.length - 1];
    const codeBlocks = latestMessage.querySelectorAll("pre code");
    let responseText = "";

    for (const block of codeBlocks) {
      if (block.className.includes("hljs-") || block.closest(".code-block")) {
        responseText = block.textContent.trim();
        break;
      }
    }

    if (!responseText) {
      responseText = latestMessage.textContent.trim();
      const jsonMatch = responseText.match(/\{[\s\S]*\}/);
      if (jsonMatch) responseText = jsonMatch[0];
    }

    responseText = responseText
      .replace(/[\u200B-\u200D\uFEFF]/g, "")
      .replace(/\n\s*/g, " ")
      .trim();

    try {
      const parsed = JSON.parse(responseText);
      if (parsed.answer && !hasResponded) {
        hasResponded = true;
        chrome.runtime.sendMessage({
          type: "geminiResponse",
          response: responseText,
        });
        observer.disconnect();
      }
    } catch (e) {
      // Not yet a valid JSON or still generating
    }
  });

  observer.observe(document.body, { childList: true, subtree: true });
}

================
File: content-scripts/mheducation.js
================
let messageListener = null;
let isAutomating = false;

function setupMessageListener() {
  if (messageListener) {
    chrome.runtime.onMessage.removeListener(messageListener);
  }

  messageListener = (message, sender, sendResponse) => {
    if (message.type === "processChatGPTResponse") {
      processChatGPTResponse(message.response);
      sendResponse({ received: true });
      return true;
    }
  };

  chrome.runtime.onMessage.addListener(messageListener);
}

function handleForcedLearning() {
  const forcedLearningAlert = document.querySelector(
    ".forced-learning .alert-error"
  );
  if (forcedLearningAlert) {
    const readButton = document.querySelector(
      '[data-automation-id="lr-tray_reading-button"]'
    );
    if (readButton) {
      readButton.click();

      waitForElement('[data-automation-id="reading-questions-button"]', 10000)
        .then((toQuestionsButton) => {
          toQuestionsButton.click();
          return waitForElement(".next-button", 10000);
        })
        .then((nextButton) => {
          nextButton.click();
          if (isAutomating) {
            setTimeout(() => {
              const container = document.querySelector(".probe-container");
              if (container && !container.querySelector(".forced-learning")) {
                const qData = parseQuestion();
                if (qData) {
                  chrome.runtime.sendMessage({
                    type: "sendQuestionToChatGPT",
                    question: qData,
                  });
                }
              }
            }, 1000);
          }
        })
        .catch((error) => {
          console.error("Error in forced learning flow:", error);
          isAutomating = false;
        });
      return true;
    }
  }
  return false;
}

function processChatGPTResponse(responseText) {
  try {
    if (handleForcedLearning()) {
      return;
    }

    const response = JSON.parse(responseText);
    const answers = Array.isArray(response.answer)
      ? response.answer
      : [response.answer];

    const container = document.querySelector(".probe-container");
    if (!container) return;

    if (container.querySelector(".awd-probe-type-matching")) {
      alert(
        "Matching Question Solution:\n\n" +
          answers.join("\n") +
          "\n\nPlease input these matches manually, then click high confidence and next."
      );
    } else if (container.querySelector(".awd-probe-type-fill_in_the_blank")) {
      const inputs = container.querySelectorAll("input.fitb-input");
      inputs.forEach((input, index) => {
        if (answers[index]) {
          input.value = answers[index];
          input.dispatchEvent(new Event("input", { bubbles: true }));
        }
      });
    } else {
      const choices = container.querySelectorAll(
        'input[type="radio"], input[type="checkbox"]'
      );

      choices.forEach((choice) => {
        const label = choice.closest("label");
        if (label) {
          const choiceText = label
            .querySelector(".choiceText")
            ?.textContent.trim();
          if (choiceText) {
            const shouldBeSelected = answers.some((ans) => {
              if (choiceText === ans) return true;

              const choiceWithoutPeriod = choiceText.replace(/\.$/, "");
              const answerWithoutPeriod = ans.replace(/\.$/, "");
              if (choiceWithoutPeriod === answerWithoutPeriod) return true;

              if (choiceText === ans + ".") return true;

              return false;
            });

            if (shouldBeSelected) {
              choice.click();
            }
          }
        }
      });
    }

    if (isAutomating) {
      waitForElement(
        '[data-automation-id="confidence-buttons--high_confidence"]:not([disabled])',
        10000
      )
        .then((button) => {
          button.click();
          return waitForElement(".next-button", 10000);
        })
        .then((nextButton) => {
          nextButton.click();
          setTimeout(() => {
            const container = document.querySelector(".probe-container");
            if (container && isAutomating) {
              const qData = parseQuestion();
              if (qData) {
                chrome.runtime.sendMessage({
                  type: "sendQuestionToChatGPT",
                  question: qData,
                });
              }
            }
          }, 1000);
        })
        .catch((error) => {
          console.error("Automation error:", error);
          isAutomating = false;
        });
    }
  } catch (e) {
    console.error("Error processing response:", e);
  }
}

function addAssistantButton() {
  waitForElement("awd-header .header__navigation").then((headerNav) => {
    const buttonContainer = document.createElement("div");
    buttonContainer.style.display = "flex";
    buttonContainer.style.marginLeft = "10px";

    chrome.storage.sync.get("aiModel", function (data) {
      const aiModel = data.aiModel || "chatgpt";
      const modelName = aiModel === "chatgpt" ? "ChatGPT" : "Gemini";

      const btn = document.createElement("button");
      btn.textContent = `Ask ${modelName}`;
      btn.classList.add("btn", "btn-secondary");
      btn.style.borderTopRightRadius = "0";
      btn.style.borderBottomRightRadius = "0";
      btn.addEventListener("click", () => {
        if (isAutomating) {
          isAutomating = false;
          chrome.storage.sync.get("aiModel", function (data) {
            const currentModel = data.aiModel || "chatgpt";
            const currentModelName =
              currentModel === "chatgpt" ? "ChatGPT" : "Gemini";
            btn.textContent = `Ask ${currentModelName}`;
          });
        } else {
          const proceed = confirm(
            "Start automated answering? Click OK to begin, or Cancel to stop."
          );
          if (proceed) {
            isAutomating = true;
            btn.textContent = "Stop Automation";
            const qData = parseQuestion();
            if (qData) {
              chrome.runtime.sendMessage({
                type: "sendQuestionToChatGPT",
                question: qData,
              });
            }
          }
        }
      });

      const settingsBtn = document.createElement("button");
      settingsBtn.classList.add("btn", "btn-secondary");
      settingsBtn.style.borderTopLeftRadius = "0";
      settingsBtn.style.borderBottomLeftRadius = "0";
      settingsBtn.style.borderLeft = "1px solid rgba(0,0,0,0.2)";
      settingsBtn.style.padding = "6px 10px";
      settingsBtn.title = "Auto-McGraw Settings";
      settingsBtn.innerHTML = `
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="12" cy="12" r="3"></circle>
          <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
        </svg>
      `;
      settingsBtn.addEventListener("click", () => {
        chrome.runtime.sendMessage({ type: "openSettings" });
      });

      buttonContainer.appendChild(btn);
      buttonContainer.appendChild(settingsBtn);
      headerNav.appendChild(buttonContainer);

      chrome.storage.onChanged.addListener((changes) => {
        if (changes.aiModel) {
          const newModel = changes.aiModel.newValue;
          const newModelName = newModel === "chatgpt" ? "ChatGPT" : "Gemini";
          if (!isAutomating) {
            btn.textContent = `Ask ${newModelName}`;
          }
        }
      });
    });
  });
}

function parseQuestion() {
  const container = document.querySelector(".probe-container");
  if (!container) {
    alert("No question found on the page.");
    return null;
  }

  let questionType = "";
  if (container.querySelector(".awd-probe-type-multiple_choice")) {
    questionType = "multiple_choice";
  } else if (container.querySelector(".awd-probe-type-true_false")) {
    questionType = "true_false";
  } else if (container.querySelector(".awd-probe-type-multiple_select")) {
    questionType = "multiple_select";
  } else if (container.querySelector(".awd-probe-type-fill_in_the_blank")) {
    questionType = "fill_in_the_blank";
  } else if (container.querySelector(".awd-probe-type-matching")) {
    questionType = "matching";
  }

  let questionText = "";
  const promptEl = container.querySelector(".prompt");

  if (questionType === "fill_in_the_blank" && promptEl) {
    const promptClone = promptEl.cloneNode(true);

    const inputs = promptClone.querySelectorAll("input.fitb-input");
    inputs.forEach((input) => {
      const blankMarker = document.createTextNode("[BLANK]");
      input.parentNode.replaceChild(blankMarker, input);
    });

    questionText = promptClone.textContent.trim();
  } else {
    questionText = promptEl ? promptEl.textContent.trim() : "";
  }

  let options = [];
  if (questionType === "matching") {
    const prompts = Array.from(
      container.querySelectorAll(".match-prompt .content")
    ).map((el) => el.textContent.trim());
    const choices = Array.from(
      container.querySelectorAll(".choices-container .content")
    ).map((el) => el.textContent.trim());
    options = { prompts, choices };
  } else if (questionType !== "fill_in_the_blank") {
    container.querySelectorAll(".choiceText").forEach((el) => {
      options.push(el.textContent.trim());
    });
  }

  return { type: questionType, question: questionText, options: options };
}

function waitForElement(selector, timeout = 5000) {
  return new Promise((resolve, reject) => {
    const startTime = Date.now();
    const interval = setInterval(() => {
      const el = document.querySelector(selector);
      if (el) {
        clearInterval(interval);
        resolve(el);
      } else if (Date.now() - startTime > timeout) {
        clearInterval(interval);
        reject(new Error("Element not found: " + selector));
      }
    }, 100);
  });
}

setupMessageListener();
addAssistantButton();

================
File: LICENSE
================
MIT License

Copyright (c) 2025 GooglyBlox

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: manifest.json
================
{
  "manifest_version": 3,
  "name": "Auto-McGraw Smartbook",
  "version": "1.6",
  "description": "Transfers a question from MHEducation's Smartbook to AI assistants and then uses their response to auto‐select an answer.",
  "permissions": ["tabs", "scripting", "storage"],
  "host_permissions": [
    "https://learning.mheducation.com/*",
    "https://chatgpt.com/*",
    "https://gemini.google.com/*"
  ],
  "background": {
    "service_worker": "background/background.js"
  },
  "icons": {
    "48": "assets/icon.png"
  },
  "action": {
    "default_popup": "popup/settings.html",
    "default_icon": "assets/icon.png"
  },
  "content_scripts": [
    {
      "matches": ["https://learning.mheducation.com/static/awd/*"],
      "js": ["content-scripts/mheducation.js"]
    },
    {
      "matches": ["https://chatgpt.com/*"],
      "js": ["content-scripts/chatgpt.js"]
    },
    {
      "matches": ["https://gemini.google.com/*"],
      "js": ["content-scripts/gemini.js"]
    }
  ],
  "web_accessible_resources": [
    {
      "resources": [
        "popup/settings.html",
        "popup/settings.css",
        "popup/settings.js"
      ],
      "matches": ["<all_urls>"]
    }
  ]
}

================
File: popup/settings.css
================
:root {
  --primary-color: #1a1a1a;
  --secondary-color: #2d2d2d;
  --text-color: #f0f0f0;
  --highlight-color: #3949ab;
  --border-color: #444;
  --chatgpt-color: #10a37f;
  --gemini-color: #8e24aa;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
    Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
  margin: 0;
  padding: 0;
  background-color: var(--primary-color);
  color: var(--text-color);
}

.container {
  width: 360px;
  margin: 0 auto;
  padding: 16px;
}

header {
  display: flex;
  align-items: center;
  margin-bottom: 24px;
  padding-bottom: 12px;
  border-bottom: 1px solid var(--border-color);
}

.logo {
  width: 32px;
  height: 32px;
  margin-right: 12px;
}

h1 {
  font-size: 18px;
  margin: 0;
}

h2 {
  font-size: 16px;
  margin-bottom: 8px;
}

h3 {
  font-size: 14px;
  margin: 0 0 4px 0;
}

p {
  font-size: 13px;
  margin: 0 0 12px 0;
  opacity: 0.8;
}

.settings-section {
  background-color: var(--secondary-color);
  border-radius: 8px;
  padding: 16px;
  margin-bottom: 16px;
}

.model-selector {
  display: flex;
  gap: 12px;
  margin-bottom: 16px;
}

.model-button {
  flex: 1;
  display: flex;
  align-items: center;
  background-color: var(--primary-color);
  border: 1px solid var(--border-color);
  border-radius: 6px;
  padding: 12px;
  cursor: pointer;
  color: var(--text-color);
  text-align: left;
  transition: all 0.2s ease;
}

.model-button:hover {
  border-color: #666;
}

.model-button.active {
  border: 2px solid var(--highlight-color);
}

.model-icon {
  width: 24px;
  height: 24px;
  border-radius: 4px;
  margin-right: 12px;
  background-position: center;
  background-size: cover;
}

.chatgpt-icon {
  background-color: var(--chatgpt-color);
}

.gemini-icon {
  background-color: var(--gemini-color);
}

.model-details {
  flex: 1;
}

.status-section {
  background-color: var(--primary-color);
  border-radius: 6px;
  padding: 12px;
  margin-top: 16px;
}

#status-message {
  font-size: 13px;
  opacity: 0.9;
}

footer {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 12px;
  opacity: 0.7;
}

footer a {
  color: var(--text-color);
  text-decoration: none;
}

footer a:hover {
  text-decoration: underline;
}

================
File: popup/settings.html
================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Auto-McGraw Settings</title>
    <link rel="stylesheet" href="settings.css" />
  </head>
  <body>
    <div class="container">
      <header>
        <img src="../assets/icon.png" alt="Auto-McGraw Logo" class="logo" />
        <h1>Auto-McGraw Settings</h1>
      </header>

      <div class="settings-section">
        <h2>AI Assistant</h2>
        <p>Select which AI assistant to use for answering questions.</p>

        <div class="model-selector">
          <button id="chatgpt" class="model-button active">
            <div class="model-icon chatgpt-icon"></div>
            <div class="model-details">
              <h3>ChatGPT</h3>
              <p>OpenAI's ChatGPT model</p>
            </div>
          </button>

          <button id="gemini" class="model-button">
            <div class="model-icon gemini-icon"></div>
            <div class="model-details">
              <h3>Gemini</h3>
              <p>Google's Gemini model</p>
            </div>
          </button>
        </div>

        <div class="status-section">
          <h3>Status</h3>
          <div id="status-message">Checking assistant availability...</div>
        </div>
      </div>

      <footer>
        <p>Auto-McGraw v1.5 by GooglyBlox</p>
        <a href="https://github.com/GooglyBlox/auto-mcgraw" target="_blank"
          >GitHub</a
        >
      </footer>
    </div>
    <script src="settings.js"></script>
  </body>
</html>

================
File: popup/settings.js
================
document.addEventListener("DOMContentLoaded", function () {
  const chatgptButton = document.getElementById("chatgpt");
  const geminiButton = document.getElementById("gemini");
  const statusMessage = document.getElementById("status-message");

  chrome.storage.sync.get("aiModel", function (data) {
    const currentModel = data.aiModel || "chatgpt";

    if (currentModel === "chatgpt") {
      chatgptButton.classList.add("active");
      geminiButton.classList.remove("active");
    } else {
      geminiButton.classList.add("active");
      chatgptButton.classList.remove("active");
    }

    checkModelAvailability(currentModel);
  });

  chatgptButton.addEventListener("click", function () {
    setActiveModel("chatgpt");
  });

  geminiButton.addEventListener("click", function () {
    setActiveModel("gemini");
  });

  function setActiveModel(model) {
    chrome.storage.sync.set({ aiModel: model }, function () {
      if (model === "chatgpt") {
        chatgptButton.classList.add("active");
        geminiButton.classList.remove("active");
      } else {
        geminiButton.classList.add("active");
        chatgptButton.classList.remove("active");
      }

      checkModelAvailability(model);
    });
  }

  function checkModelAvailability(currentModel) {
    statusMessage.textContent = "Checking assistant availability...";

    chrome.tabs.query({ url: "https://chatgpt.com/*" }, (chatgptTabs) => {
      const chatgptAvailable = chatgptTabs.length > 0;

      chrome.tabs.query(
        { url: "https://gemini.google.com/*" },
        (geminiTabs) => {
          const geminiAvailable = geminiTabs.length > 0;

          if (currentModel === "chatgpt") {
            if (chatgptAvailable) {
              statusMessage.textContent =
                "✓ ChatGPT tab is open and ready to use.";
              statusMessage.style.color = "#4caf50";
            } else {
              statusMessage.textContent =
                "✗ Please open ChatGPT in another tab to use this assistant.";
              statusMessage.style.color = "#f44336";
            }
          } else {
            if (geminiAvailable) {
              statusMessage.textContent =
                "✓ Gemini tab is open and ready to use.";
              statusMessage.style.color = "#4caf50";
            } else {
              statusMessage.textContent =
                "✗ Please open Gemini in another tab to use this assistant.";
              statusMessage.style.color = "#f44336";
            }
          }
        }
      );
    });
  }
});

================
File: README.md
================
<div align="center">

# Auto-McGraw (Smartbook)

<img src="icon.png" alt="Auto-McGraw Logo" width="200">

[![Release](https://img.shields.io/github/v/release/GooglyBlox/auto-mcgraw?include_prereleases&style=flat-square&cache=1)](https://github.com/GooglyBlox/auto-mcgraw/releases)
[![License](https://img.shields.io/github/license/GooglyBlox/auto-mcgraw?style=flat-square&cache=1)](LICENSE)
[![Issues](https://img.shields.io/github/issues/GooglyBlox/auto-mcgraw?style=flat-square&cache=1)](https://github.com/GooglyBlox/auto-mcgraw/issues)

*Automate your McGraw Hill Smartbook homework with AI integration (ChatGPT & Gemini)*

[Installation](#installation) • [Usage](#usage) • [Settings](#settings) • [Issues](#issues)

</div>

---

## Installation

1. Download the latest zip from the [releases page](https://github.com/GooglyBlox/auto-mcgraw/releases)
2. Extract the zip file to a folder
3. Open Chrome and go to `chrome://extensions/`
4. Enable "Developer mode" in the top right
5. Click "Load unpacked" and select the extracted folder

## Usage

1. Log into your McGraw Hill account and open a Smartbook assignment
2. Log into [ChatGPT](https://chatgpt.com) or [Gemini](https://gemini.google.com) in another tab (the extension requires an active AI session)
3. Click the "Ask [AI Model]" button that appears in your Smartbook header
4. Click "OK" when prompted to begin automation
5. Watch as the extension:
   - Sends questions to your chosen AI assistant
   - Processes the responses
   - Automatically fills in answers
   - Handles multiple choice, true/false, and fill-in-the-blank questions
      - **Note about matching questions:** Due to technical limitations, matching questions cannot be automated. When encountering a matching question, the extension will show you AI-suggested matches in an alert. You'll need to manually drag and drop the matches, then the extension will continue with automation.
   - Navigates through forced learning sections when needed

Click "Stop Automation" at any time to pause the process.

## Settings

Click the settings icon (⚙️) next to the main button to access the settings menu, where you can:

- Choose between **ChatGPT** and **Gemini** for answering questions
- See the status of your AI assistant connections
- Check if your selected AI assistant is ready to use

The extension will automatically use your selected AI model for all future automation sessions.

## Disclaimer

This tool is for educational purposes only. Use it responsibly and be aware of your institution's academic integrity policies.

## Issues

Found a bug? [Create an issue](https://github.com/GooglyBlox/auto-mcgraw/issues).
